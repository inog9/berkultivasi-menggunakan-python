#!/usr/bin/env python3
#pip install psutil watchdog

import os
import sys
import json
import time
import logging
import argparse
import psutil
import shutil
import tempfile
import subprocess
from datetime import datetime
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Konfigurasi logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('sandbox_analisis.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class FileSystemMonitor(FileSystemEventHandler):
    def __init__(self):
        self.changes = {
            'created': [],
            'modified': [],
            'deleted': []
        }
        self.startup_folders = [
            os.path.expanduser('~/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup'),
            os.path.expanduser('~/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup'),
            'C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp'
        ]

    def on_created(self, event):
        if not event.is_directory:
            self.changes['created'].append({
                'path': event.src_path,
                'timestamp': datetime.now().isoformat(),
                'is_persistence': event.src_path in self.startup_folders
            })

    def on_modified(self, event):
        if not event.is_directory:
            self.changes['modified'].append({
                'path': event.src_path,
                'timestamp': datetime.now().isoformat()
            })

    def on_deleted(self, event):
        if not event.is_directory:
            self.changes['deleted'].append({
                'path': event.src_path,
                'timestamp': datetime.now().isoformat()
            })

class SandboxAnalyzer:
    def __init__(self, sample_path, timeout=30):
        self.sample_path = Path(sample_path)
        self.timeout = timeout
        self.sandbox_dir = None
        self.monitor = FileSystemMonitor()
        self.observer = None
        self.initial_processes = set()
        self.initial_files = set()

    def setup_sandbox(self):
        """Menyiapkan lingkungan sandbox"""
        try:
            # Buat direktori sandbox
            self.sandbox_dir = Path(tempfile.mkdtemp(prefix='sandbox_'))
            logging.info(f"Sandbox directory created: {self.sandbox_dir}")

            # Salin sample ke sandbox
            sample_copy = self.sandbox_dir / self.sample_path.name
            shutil.copy2(self.sample_path, sample_copy)
            logging.info(f"Sample copied to sandbox: {sample_copy}")

            # Catat proses dan file awal
            self.initial_processes = set(p.pid for p in psutil.process_iter())
            self.initial_files = set(str(p) for p in self.sandbox_dir.rglob('*'))

            return sample_copy

        except Exception as e:
            logging.error(f"Error setting up sandbox: {str(e)}")
            self.cleanup()
            raise

    def monitor_changes(self):
        """Memulai monitoring perubahan file"""
        self.observer = Observer()
        self.observer.schedule(self.monitor, str(self.sandbox_dir), recursive=True)
        self.observer.start()

    def get_process_changes(self):
        """Mendapatkan perubahan proses"""
        current_processes = set(p.pid for p in psutil.process_iter())
        new_processes = current_processes - self.initial_processes
        
        process_details = []
        for pid in new_processes:
            try:
                p = psutil.Process(pid)
                process_details.append({
                    'pid': pid,
                    'name': p.name(),
                    'cmdline': p.cmdline(),
                    'create_time': datetime.fromtimestamp(p.create_time()).isoformat(),
                    'status': p.status()
                })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        return process_details

    def get_file_changes(self):
        """Mendapatkan perubahan file"""
        current_files = set(str(p) for p in self.sandbox_dir.rglob('*'))
        new_files = current_files - self.initial_files

        file_details = []
        for file_path in new_files:
            try:
                path = Path(file_path)
                if path.is_file():
                    stat = path.stat()
                    file_details.append({
                        'path': str(path),
                        'size': stat.st_size,
                        'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            except Exception as e:
                logging.warning(f"Error getting file details for {file_path}: {str(e)}")

        return file_details

    def run_sample(self, sample_path):
        """Menjalankan sample dalam sandbox"""
        try:
            # Mulai monitoring
            self.monitor_changes()
            
            # Jalankan sample
            process = subprocess.Popen(
                [str(sample_path)],
                cwd=str(self.sandbox_dir),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )

            # Tunggu dengan timeout
            try:
                process.wait(timeout=self.timeout)
            except subprocess.TimeoutExpired:
                process.kill()
                logging.warning(f"Sample execution timed out after {self.timeout} seconds")

            # Tunggu sebentar untuk memastikan semua perubahan tercatat
            time.sleep(2)

            # Kumpulkan hasil
            results = {
                'timestamp': datetime.now().isoformat(),
                'sample': {
                    'name': self.sample_path.name,
                    'path': str(self.sample_path),
                    'size': self.sample_path.stat().st_size
                },
                'sandbox': {
                    'directory': str(self.sandbox_dir),
                    'duration': self.timeout
                },
                'processes': self.get_process_changes(),
                'filesystem_changes': self.monitor.changes,
                'new_files': self.get_file_changes(),
                'persistence_attempts': [
                    change for change in self.monitor.changes['created']
                    if change['is_persistence']
                ]
            }

            return results

        except Exception as e:
            logging.error(f"Error running sample: {str(e)}")
            raise

    def cleanup(self):
        """Membersihkan sandbox"""
        if self.observer:
            self.observer.stop()
            self.observer.join()

        if self.sandbox_dir and self.sandbox_dir.exists():
            try:
                shutil.rmtree(self.sandbox_dir)
                logging.info("Sandbox directory cleaned up")
            except Exception as e:
                logging.error(f"Error cleaning up sandbox: {str(e)}")

def main():
    parser = argparse.ArgumentParser(description='Behavioral Sandbox Analysis')
    parser.add_argument('sample', help='Path to the sample file (.exe or .dll)')
    parser.add_argument('-o', '--output', help='Output JSON file', default='sandbox_report.json')
    parser.add_argument('-t', '--timeout', type=int, help='Execution timeout in seconds', default=30)
    
    args = parser.parse_args()

    try:
        # Validasi input
        sample_path = Path(args.sample)
        if not sample_path.exists():
            logging.error(f"Sample file not found: {args.sample}")
            sys.exit(1)

        if sample_path.suffix.lower() not in ['.exe', '.dll']:
            logging.error("Sample must be an .exe or .dll file")
            sys.exit(1)

        # Jalankan analisis
        analyzer = SandboxAnalyzer(sample_path, args.timeout)
        sample_copy = analyzer.setup_sandbox()
        
        try:
            results = analyzer.run_sample(sample_copy)
            
            # Simpan hasil
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            logging.info(f"Analysis results saved to {args.output}")

        finally:
            analyzer.cleanup()

    except Exception as e:
        logging.error(f"Analysis failed: {str(e)}")
        sys.exit(1)

if __name__ == '__main__':
    main() 


#python sandbox_analisis.py path/to/sample.exe -o report.json -t 60